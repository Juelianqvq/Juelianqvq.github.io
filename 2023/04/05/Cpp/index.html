<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[2022](# 2022) – [1.Cpp](# 1.Cpp) – [2.Cherno](# 2.Cherno) – [3.C++ Primer](# 3.C++ Primer) [2023](# 2023) – [1.Cpp](# 1.Cpp) 20221.Cpp   引用类型     使用场景     非常量左值 常量左值 非常量右值 常量右值    非常量左值引用 Y N N N 无">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp">
<meta property="og:url" content="http://example.com/2023/04/05/Cpp/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[2022](# 2022) – [1.Cpp](# 1.Cpp) – [2.Cherno](# 2.Cherno) – [3.C++ Primer](# 3.C++ Primer) [2023](# 2023) – [1.Cpp](# 1.Cpp) 20221.Cpp   引用类型     使用场景     非常量左值 常量左值 非常量右值 常量右值    非常量左值引用 Y N N N 无">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-04-05T04:47:47.000Z">
<meta property="article:modified_time" content="2023-11-20T15:24:52.072Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Cpp">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/04/05/Cpp/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Cpp | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/05/Cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-05 12:47:47" itemprop="dateCreated datePublished" datetime="2023-04-05T12:47:47+08:00">2023-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-20 23:24:52" itemprop="dateModified" datetime="2023-11-20T23:24:52+08:00">2023-11-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[2022](# 2022)</p>
<p>– [1.Cpp](# 1.Cpp)</p>
<p>– [2.Cherno](# 2.Cherno)</p>
<p>– [3.C++ Primer](# 3.C++ Primer)</p>
<p>[2023](# 2023)</p>
<p>– [1.Cpp](# 1.Cpp)</p>
<h2 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h2><h4 id="1-Cpp"><a href="#1-Cpp" class="headerlink" title="1.Cpp"></a>1.Cpp</h4><table>
<thead>
<tr>
<th>引用类型</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>非常量左值</td>
<td>常量左值</td>
<td>非常量右值</td>
<td>常量右值</td>
<td></td>
</tr>
<tr>
<td>非常量左值引用</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>无</td>
</tr>
<tr>
<td>常量左值引用</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>常用于类中构建拷贝构造函数</td>
</tr>
<tr>
<td>非常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>移动语义、完美转发</td>
</tr>
<tr>
<td>常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>无实际用途</td>
</tr>
</tbody></table>
<p>清晰的左右值，左右引用：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2ed2689afa49">https://www.jianshu.com/p/2ed2689afa49</a></p>
<p>左值右值：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/402251966">https://zhuanlan.zhihu.com/p/402251966</a></p>
<p>std::map：<a target="_blank" rel="noopener" href="https://blog.csdn.net/loveC__/article/details/88702666">https://blog.csdn.net/loveC__/article/details/88702666</a></p>
<p>set vector互转：<a target="_blank" rel="noopener" href="https://blog.csdn.net/SL_World/article/details/114664645">https://blog.csdn.net/SL_World/article/details/114664645</a></p>
<p><strong>容易错误的左值：</strong></p>
<blockquote>
<p>1.字符串字面量，如：<code>&quot;Hello&quot;</code><br>2.内置的前++与前–，如：<code>++a</code><br><strong>3.变量类型是右值引用的表达式</strong>，如：<code>TestClassA&amp;&amp; ra = TestClassA(1000);</code>ra是左值<br>4.转型为左值引用的表达式，如：<code>static_cast&lt;double&amp;&gt;(fValue)</code>;<br>5.内置*解引用的表达式，如：<code>*pkValue</code></p>
</blockquote>
<p><strong>容易错误的右值：</strong></p>
<blockquote>
<p>1.非字符串的字面量以及枚举项，如：<code>nullptr</code>,<code>true</code><br>2.内置的后++与后–，如：<code>a--</code><br>3.内置的算术，逻辑，比较表达式，如：<code>a+b</code>，<code>a&amp;b</code>，<code>a||b</code>, <code>a&lt;b</code><br>4.内置取地址表达式，this指针，如:<code>&amp;a</code><br>5.lamda表达式,如：<code>[](int a)&#123; return 2*a; &#125;</code><br>6.转型为非引用的表达式，如：<code>static_cast&lt;double&gt;(fValue)</code>, <code>(float)42</code><br>7.转型为右值引用的表达式，如：<code>static_cast&lt;double&amp;&amp;&gt;(fValue)</code>，<code>std::move(x)</code>;</p>
<p>8.<strong>亡值：生命周期即将结束的表达式，如TestClassA(100)</strong></p>
</blockquote>
<h4 id="2-Cherno"><a href="#2-Cherno" class="headerlink" title="2.Cherno"></a>2.Cherno</h4><p>1.<strong>指针和引用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Log(x) std::cout &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment_1</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment_2</span><span class="params">(<span class="type">int</span>* val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*val)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment_3</span><span class="params">(<span class="type">int</span>&amp; val)</span> <span class="comment">//引用传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Increment_1</span>(a);</span><br><span class="line">    <span class="built_in">Log</span>(a);</span><br><span class="line">    <span class="built_in">Increment_2</span>(&amp;a);</span><br><span class="line">    <span class="built_in">Log</span>(a);</span><br><span class="line">    <span class="built_in">Increment_3</span>(a);</span><br><span class="line">    <span class="built_in">Log</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>Static</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//1.类内</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y; <span class="comment">//本质上不属于类，而更像是类命名空间下的普通变量</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="comment">//共享一个内存，只有一个实例</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//commenting following 2 lines will meet an error,因为一定需要定义才能访问到,这两行是必须要有的</span></span><br><span class="line"><span class="type">int</span> entity::x;</span><br><span class="line"><span class="type">int</span> entity::y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1:Instance</span></span><br><span class="line">    entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">2</span>; </span><br><span class="line">    <span class="comment">// 2:Namespace</span></span><br><span class="line">    entity::x = <span class="number">2</span>;</span><br><span class="line">    entity::y = <span class="number">3</span>;</span><br><span class="line">    entity::<span class="built_in">Print</span>();  <span class="comment">// One instance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.<strong>单例类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//与2一致，主要是int-&gt;Singleton*，实例为Singleton</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1：不使用局部静态创建单例类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//这也是为什么需要用Get去访问得到</span></span><br><span class="line">	<span class="type">static</span> Singleton* s_Instance;  <span class="comment">// 静态成员变量，Singleton类型的指针实例</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *s_Instance; &#125;;<span class="comment">// 返回Singleton类实例的引用，解引用*是为了得到类，而不是类的指针</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span></span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::s_Instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    	<span class="comment">// Singleton::Get()就得到一个单例的对象，由于是类似命名空间直接调用类的方法得到的，而不是对象的方法，因此只有一个实例</span></span><br><span class="line">	Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2：使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 返回Singleton类型的实例的引用</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> <span class="comment">//不加static,在堆栈上创建变量，在运行到花括号时就会销毁，返回引用(复制)就会出问题</span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="type">static</span> Singleton instance;   <span class="comment">// 这里的static，和函数中的local static是一样的功能</span></span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.<strong>虚函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//虚函数允许在子类中重写方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">m_Name</span>(name) &#123;&#125; <span class="comment">//构造函数接收输入的字符串作为m_Name进行初始化</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> <span class="comment">//写了virtual就会往子类去找，为什么这里需要传一个指针，指针能区分 到底是哪个类</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity -&gt; <span class="built_in">GetName</span>() &lt;&lt; std::endl; <span class="comment">//指针指向的是类的实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();  <span class="comment">//分配内存</span></span><br><span class="line">    <span class="built_in">PrintName</span>(e);</span><br><span class="line"></span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    <span class="built_in">PrintName</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Entity* entity = p;//指向player的实例，但得到的是Entity</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; entity -&gt; GetName() &lt;&lt; std::endl;</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.<strong>纯虚函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//不写明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity -&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Kwx&quot;</span>);</span><br><span class="line">    <span class="built_in">PrintName</span>(e);</span><br><span class="line"></span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    <span class="built_in">PrintName</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.<strong>接口</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span>  <span class="comment">//接口就是一个类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> : <span class="keyword">public</span> Printable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name) :<span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Printable* obj)</span> <span class="comment">//因为有继承关系，所以要用指针区分？ 和7没区别</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;<span class="built_in">GetClassName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">        Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Kwx&quot;</span>);</span><br><span class="line">        <span class="built_in">Print</span>(e);</span><br><span class="line">        <span class="built_in">Print</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>14.<strong>拷贝构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_Buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_Size; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) <span class="comment">//默认浅拷贝，指针就是地址，区别在于是否重新开辟</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> <span class="type">char</span>[m_Size + <span class="number">1</span>]; <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="comment">// 在对含有指针成员的对象进行拷贝时，必须自己定义拷贝构造函数，达到深拷贝的目的，才能避免内存重复释放</span></span><br><span class="line">        <span class="comment">// 类中存在指针成员变量的时候，并且这个指针是指向堆上的内存。浅拷贝复制的时候仅仅复制指针，而不会复制指针指向的内存的数据</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; m_Size; i++)</span></span><br><span class="line">        <span class="comment">//     m_Buffer[i] = string[i]；</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer, string, m_Size + <span class="number">1</span>); <span class="comment">// 从源内存地址拷贝若干字节到目标地址，两个都是地址</span></span><br><span class="line">        m_Buffer[m_Size] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="comment">//这是一个有参构造函数，构造完自动给你分配一个内存</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_Buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> <span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Buffer[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝：在堆区创建新内存，实际上就是other的地址，other的地址是作为成员变量时自动分配的属性</span></span><br><span class="line">    <span class="comment">// 拷贝构造函数也是有参构造函数，区别就是，把源地址other.m_buffer完全拷贝到新开辟的m_buffer</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) <span class="comment">// 深拷贝，因为是字符串，所以一定带有终止符，在用一个对象初始化时，开辟新的内存</span></span><br><span class="line">        :<span class="built_in">m_Size</span>(other.m_Size)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> <span class="type">char</span>[m_Size + <span class="number">1</span>]; <span class="comment">//开辟一块新的内存</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer, other.m_Buffer, m_Size + <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String(const String&amp; other)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     memcpy(this, &amp;other, sizeof(String)); 这个才是地址</span></span><br><span class="line">    <span class="comment">// this指针是类的一个自动生成、自动隐藏的私有成员，存在于类的非静态成员函数中，指向被调用函数所在的对象。</span></span><br><span class="line">    <span class="comment">// 也就是理解成当前对象的地址(拷贝到的地址)                                           </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; string.m_Buffer;</span><br><span class="line">    <span class="keyword">return</span> stream; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不改写成引用，会出现三次copy,const表示不能编辑现有的字符串</span></span><br><span class="line"><span class="comment">// 除此之外也意味着可以把临时的右值传递到实际的函数中, 出现三次的原因是调用了拷贝构造函数，而引用时不进行拷贝</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintString</span><span class="params">(<span class="type">const</span> String&amp; string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; string &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用有参构造函数生成cherno，然后复制给新对象，默认的拷贝是浅拷贝，只复制指针，&#x27;=&#x27;可以是浅也可以是深</span></span><br><span class="line">    String string = <span class="string">&quot;Cherno&quot;</span>; <span class="comment">//没有分配新的内存块来存储</span></span><br><span class="line">    <span class="comment">// 这里的 = 就是一次deepcopy 是必定会调用copy的</span></span><br><span class="line">    String second = string;  <span class="comment">// 当前一个对象被释放的时候，其指针成员变量一并被释放，导致这块内存无效。</span></span><br><span class="line">                             <span class="comment">// 而后一个对象的指针成员变量还是指向堆上的这块内存，当后一个对象被释放的时候它再次尝试释放堆上的这块内存，从而报错。</span></span><br><span class="line">    second[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>; <span class="comment">//引用不进行拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintString</span>(string); <span class="comment">// 两个对象都得到了保留，没有出现内存重复释放的话意味着非引用的传参也是深拷贝</span></span><br><span class="line">    <span class="built_in">PrintString</span>(second); </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>19.<strong>函数指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hi&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintValue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value:&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">void</span>(*func)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> value : values)</span><br><span class="line">        <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针是将一个函数赋值给一个变量的方法,</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// auto func = Hi(); 因为没有返回值，所以无法推断auto</span></span><br><span class="line">    <span class="comment">// auto func = Hi;</span></span><br><span class="line">    <span class="comment">// func();</span></span><br><span class="line">    <span class="comment">// 将function作为一个变量名进行调用，将函数参数化</span></span><br><span class="line">    <span class="built_in">void</span>(*func)() = Hi; <span class="comment">// 函数指针变量的命名是在中间</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*HiFunction1)</span><span class="params">()</span></span>; <span class="comment">// 为类型取一个新的名字，无参</span></span><br><span class="line">    HiFunction1 function1 = Hi;</span><br><span class="line">    <span class="built_in">function1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*HiFunction2)</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// 有参</span></span><br><span class="line">    HiFunction2 function2 = Hello; <span class="comment">// 需要改变这里的函数定义</span></span><br><span class="line">    <span class="built_in">function2</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">ForEach</span>(values, PrintValue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ForEach</span>(values, [](<span class="type">int</span> value) &#123; std::cout &lt;&lt; <span class="string">&quot;Value:&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; value &lt;&lt; std::endl; &#125; );</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach1</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">void</span>(*func)(<span class="type">int</span>))</span> <span class="comment">// 这里使用的是原始函数指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> value : values)</span><br><span class="line">        <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach2</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; values, <span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> value : values)</span><br><span class="line">        <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有一个函数指针就可以用匿名函数lambda</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value &gt; <span class="number">1</span>; &#125;); <span class="comment">// 返回迭代器，即满足条件的第一个元素</span></span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面的函数指针需要一个int参数 void(*func)(int),lambda指定未来想要运行的代码</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = [](<span class="type">int</span> value) &#123; std::cout &lt;&lt; <span class="string">&quot;Value:&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; value &lt;&lt; std::endl; &#125;;</span><br><span class="line">    <span class="built_in">ForEach1</span>(values, lambda);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// auto lambda = [](int value) &#123;std::cout &lt;&lt; &quot; Value:&quot; &lt;&lt; a &lt;&lt; std::endl;&#125;;      //不传递任何外部变量</span></span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=](<span class="type">int</span> value) &#123;std::cout &lt;&lt; <span class="string">&quot; Value:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;&#125;;     <span class="comment">//拷贝这个变量然后传入，=a就是值传递a</span></span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;](<span class="type">int</span> value) &#123;std::cout &lt;&lt; <span class="string">&quot; Value:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;&#125;;     <span class="comment">//&amp;a就是引用传递a</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>24.<strong>虚析构函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Constructed\n&quot;</span>; &#125;</span><br><span class="line">    <span class="comment">// 加了virtual意味着这个类有可能被扩展为子类，可能还有一个析构函数会被调用，需要调用派生类的析构函数(如果存在的话)</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; m_array = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">5</span>]; std::cout &lt;&lt; <span class="string">&quot;Derived Constructed\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; <span class="keyword">delete</span>[] m_array; std::cout &lt;&lt; <span class="string">&quot;Derived Destructed\n&quot;</span>; &#125; <span class="comment">// 也就是这句话永远没有被调用，导致内存泄漏</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> derived; </span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Base* poly = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 多态：基类指针指向派生类对象</span></span><br><span class="line">    <span class="keyword">delete</span> poly; <span class="comment">// 调用了派生类的构造函数但是没有调用其析构函数</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>29.<strong>再探单例类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++中的单例只是一种组织一堆全局变量和静态函数的方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> <span class="comment">// 2.提供静态访问该类的方法,返回这种特定类型的引用或指针</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s_Instance; <span class="comment">// 3.需要返回某种Singleton的实例，对于整个程序单例类只有一个实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 1.如果有公共的构造函数就会允许被实例化，不能在外部被实例化</span></span><br><span class="line">    <span class="type">float</span> m_Member = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">static</span> Singleton s_Instance; <span class="comment">// 4.传统方法是在私有成员里创建单例类的静态实例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::s_Instance; <span class="comment">// 5.static需要类外定义, get方法可直接返回s_Instance</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton::<span class="built_in">Get</span>().<span class="built_in">Function</span>(); <span class="comment">// 6.访问单例的方法</span></span><br><span class="line">    <span class="comment">// 7.如果这样做，单例的所有数据都被复制，所以通常要删除拷贝构造函数，标记其为delete</span></span><br><span class="line">    <span class="comment">// Singleton instance = Singleton::Get();</span></span><br><span class="line">    Singleton&amp; instance = Singleton::<span class="built_in">Get</span>(); <span class="comment">// 必须写成引用 或者auto&amp; .. = ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Random</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Random</span>(<span class="type">const</span> Random&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 单例的核心就是Get函数，此处有一个单独实例，它只会在第一次使用时创建，这个单例的生命周期就是应用的生命周期</span></span><br><span class="line">    <span class="comment">// 一旦有了这个单例，就能写任意数量的非静态方法并通过Get函数来访问它们</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Random&amp; <span class="title">Get</span><span class="params">()</span> <span class="comment">// 2.提供静态访问该类的方法,返回这种特定类型的引用或指针</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 实际上是在函数内部有个静态变量，意味着它仍存在于内存中，一旦get函数被第一次调用就完成了实例化</span></span><br><span class="line">        <span class="comment">// 在余下时间里，它只是在静态内存中被引用，与之前一致</span></span><br><span class="line">        <span class="type">static</span> Random s_instance; <span class="comment">// 不放在成员变量里定义及类外初始化</span></span><br><span class="line">        <span class="keyword">return</span> s_instance; <span class="comment">// 3.需要返回某种Singleton的实例，对于整个程序单例类只有一个实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">OFloat</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_RandomGenerator; &#125;</span><br><span class="line">    <span class="comment">// 方法3-2：</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">Float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Get</span>().<span class="built_in">IFloat</span>(); &#125; <span class="comment">// or Get().m_RandomGenerator</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 方法3-1：</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">IFloat</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_RandomGenerator; &#125; <span class="comment">// 因为不是静态函数所以可以访问所有成员，而不需要通过实例来访问</span></span><br><span class="line">    <span class="built_in">Random</span>() &#123;&#125; <span class="comment">// 1.如果有公共的构造函数就会允许被实例化，不能在外部被实例化</span></span><br><span class="line">    <span class="type">float</span> m_RandomGenerator = <span class="number">0.5f</span>;</span><br><span class="line">    <span class="comment">// static Random s_Instance; // 4.传统方法是在私有成员里创建单例类的静态实例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Random Random::s_Instance; 这里的可以移至函数体内</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//方法1：</span></span><br><span class="line">    <span class="type">float</span> number = Random::<span class="built_in">Get</span>().<span class="built_in">OFloat</span>();</span><br><span class="line">    <span class="comment">// 方法2：auto&amp; random = Random::Get();</span></span><br><span class="line">    <span class="comment">//       float number = random.Float();</span></span><br><span class="line">    <span class="comment">// 方法3</span></span><br><span class="line">    <span class="comment">// float number = Random::Float();</span></span><br><span class="line">    std::cout &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>32.<strong>移动语义</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类Entity含有一个成员Name为String类型，如果要用常量字符串来初始化这个类，就会先调用String的构造函数，再调用String的拷贝构造函数（经Entity构造函数里面调用），然后再调用String的析构函数，但是使用move操作就可以让中间的一次拷贝变成move，就可以少一次new</span></span><br><span class="line"><span class="comment">// 在实例化entity的时候，如果传入的是字符串常量（右值），则会调用拷贝的右值版本，避免了一次new，如果传入的是String（左值），则仍然会进行一次左值拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Created\n&quot;</span>);</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Copied\n&quot;</span>);</span><br><span class="line">        m_Size = other.m_Size;</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size]; <span class="comment">// 分配一个新的数据缓冲区，然后逐个复制所有的数据，将整个数据块复制到这个新的数据块中</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other) <span class="keyword">noexcept</span>  <span class="comment">// 不应该抛出异常，通过制定这个构造函数，希望除去复制</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Moved\n&quot;</span>);</span><br><span class="line">        m_Size = other.m_Size;</span><br><span class="line">        m_Data = other.m_Data; <span class="comment">// 简单地将指针赋值，指向m_Data,other.m_Data就是原来的字符串缓冲区的指针</span></span><br><span class="line">        <span class="comment">// 旧的字符串基本为空，当旧实例被销毁时，delete实际上会删除nullptr,删除nullptr相当于啥也没干</span></span><br><span class="line">        <span class="comment">// 实际上只是接管了那个旧的字符串，而不是通过复制所有的数据和分配新的内存来进行深拷贝</span></span><br><span class="line">        <span class="comment">// 实际上是浅拷贝，只是重新连接了指针</span></span><br><span class="line">        other.m_Size = <span class="number">0</span>;</span><br><span class="line">        other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Destroyed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">delete</span> m_Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_Data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_Data;</span><br><span class="line">    <span class="type">uint32_t</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(String&amp;&amp; name) <span class="comment">// 添加一个新的构造函数，接收一个临时参数</span></span><br><span class="line">        <span class="comment">// : m_Name(name) &#123;&#125; 仍然出现copy</span></span><br><span class="line">        <span class="comment">// : m_Name((String&amp;&amp;)name) &#123;&#125; // 显式地转化为一个临时对象,只分配了一次内存，将字符串移动至Entity类中，没有copy出现了move</span></span><br><span class="line">        : <span class="built_in">m_Name</span>(std::<span class="built_in">move</span>(name)) &#123;&#125; <span class="comment">// 实践中不会像上一行那样去写，但本质是一样的</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name.<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Entity entity(String(&quot;Kwx&quot;)); String(&quot;Kwx&quot;) | 实例以值传递的方式传递给函数参数时，会调用拷贝构造函数</span></span><br><span class="line">    <span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;Kwx&quot;</span>)</span></span>; <span class="comment">// 隐式构造函数 </span></span><br><span class="line">    entity.<span class="built_in">PrintName</span>(); <span class="comment">// 产生了copy意味着数据被复制，复制一个字符串需要在堆上分配内存，需要调用new char</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>33.<strong>赋值运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Created\n&quot;</span>);</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Copied\n&quot;</span>);</span><br><span class="line">        m_Size = other.m_Size;</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Moved\n&quot;</span>);</span><br><span class="line">        m_Size = other.m_Size;</span><br><span class="line">        m_Data = other.m_Data;</span><br><span class="line">        other.m_Size = <span class="number">0</span>; <span class="comment">// 移动后原位置肯定为空了</span></span><br><span class="line">        other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上没有像在移动构造函数中那样创建新对象，而是把另一个对象移动到自身这个当前对象中，所以需要覆盖当前对象</span></span><br><span class="line">    <span class="comment">// 因为当前对象可能已经分配了一些内存，如果设置m_Data等于另一个指针就会造成内存泄漏，因为没有办法删除旧的数据</span></span><br><span class="line">    <span class="comment">// 所以 1.首先删除当前数据，因为我们要把另一个对象移到自己这里 2.重新赋值所有变量,然后确保other对象处于正确状态</span></span><br><span class="line">    <span class="comment">// 通常在赋值操作符中还需要确保当前对象不等于另一个对象</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(String&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_Data;</span><br><span class="line">            m_Size = other.m_Size;</span><br><span class="line">            m_Data = other.m_Data;</span><br><span class="line">            other.m_Size = <span class="number">0</span>;</span><br><span class="line">            other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Destroyed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">delete</span> m_Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_Data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_Data;</span><br><span class="line">    <span class="type">uint32_t</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> <span class="comment">// Entity是一个额外的间接层</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(String&amp;&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(std::<span class="built_in">move</span>(name)) &#123;&#125; <span class="comment">// std::move把一个字符串转化为临时变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name.<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;Kwx&quot;</span>)</span></span>; <span class="comment">// 赋值操作符只是在做一个隐式转换并调用这个特定的字符串构造函数</span></span><br><span class="line">    entity.<span class="built_in">PrintName</span>();</span><br><span class="line"></span><br><span class="line">    String string = <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">    <span class="comment">// String dest = string; // 字符串复制到新变量，怎么把它移动到新变量呢？</span></span><br><span class="line">    <span class="comment">// String dest((String&amp;&amp;)string); // 并不优雅且也不支持所有类型例如auto</span></span><br><span class="line">    <span class="function">String <span class="title">dest1</span><span class="params">(std::move(string))</span></span>; <span class="comment">// 也可以 String dest = std::move(string)</span></span><br><span class="line">    <span class="comment">// 思路：1.肯定要先把它变成一个临时值 2.那就需要让它使用这个move构造函数，因为那块代码是从other窃取了资源</span></span><br><span class="line">    <span class="comment">// 3.从一种类型转换到另一种类型cast 4.使用一个更灵活的函数在编译时自动找出输入的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值操作符：仅当把一个变量赋值给一个已有的变量时才会被调用</span></span><br><span class="line">    String apple = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">    String dest2;</span><br><span class="line">    <span class="comment">// String dest3 = std::move(apple); 这里并没有调用赋值操作符，只是构造了一个新字符串,这里是移动构造函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Apple: &quot;</span>);</span><br><span class="line">    apple.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest: &quot;</span>);</span><br><span class="line">    dest2.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="comment">// dest = apple; // should cause error</span></span><br><span class="line">    <span class="comment">// dest2 = std::move(apple); // 转移了整个字符数组的所有权没做任何复制、任何分配或接触分配之类的事</span></span><br><span class="line">    dest2.<span class="keyword">operator</span>=(std::<span class="built_in">move</span>(apple)); <span class="comment">// 这是赋值运算符</span></span><br><span class="line">    <span class="comment">// 赋值操作符与使用构造函数的区别：使用运算符相当于 .operator=...,并像调用函数一样调用它</span></span><br><span class="line">    <span class="comment">// 开偷！</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Apple: &quot;</span>);</span><br><span class="line">    apple.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest: &quot;</span>);</span><br><span class="line">    dest2.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="comment">// apple的析构函数什么都没做，因为它试图删除一个数组而这个数组已被设为空指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++三法则：如果需要析构函数，则一定需要拷贝构造函数和新移动语义</span></span><br></pre></td></tr></table></figure>

<h4 id="3-C-Primer"><a href="#3-C-Primer" class="headerlink" title="3.C++ Primer"></a>3.C++ Primer</h4><p>字符串字面值的类型实际上就是由常量字符构成的数组</p>
<p>对象是指一块具有某种类型的内存</p>
<p>初始化变量时，初始值会被拷贝到新建的对象中；定义引用时，程序将引用与它的初始值绑定在一起，并非将初始值拷贝给引用</p>
<p>引用并非对象，所以不能定义引用的引用，也不能定义指向引用的指针</p>
<p>指针存放某个对象的地址</p>
<p>对指针的引用进行赋值，也就等价于让指针指向新值</p>
<p>引用绑定到常量上形成常量引用，常量引用不能修改其绑定的对象</p>
<p>非常量引用的初始值必须是左值，不能是表达式</p>
<p>允许常量引用绑定非常量的对象、字面值甚至表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span>&amp; a = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b = i; <span class="comment">// b也绑定i，但不允许通过b来修改i的值</span></span><br><span class="line">a = <span class="number">0</span>; <span class="comment">// 非常量可以改</span></span><br><span class="line">b = <span class="number">0</span>; <span class="comment">// Error 常量不可改,但是可以通过 i = 1</span></span><br></pre></td></tr></table></figure>

<p>普通指针不能指向常量对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> 常量指针 顶层(右-&gt;左) 可以指向非常量</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* 指向常量的指针，因为不能改*p 底层</span><br></pre></td></tr></table></figure>

<p>顶层const表示指针本身是个常量，底层表示指针所指的对象是一个常量</p>
<p>拷贝时，顶层const不会产生阻碍，拷入拷出的对象必须具有相同的底层const资格</p>
<p>关于顶层与底层：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> <span class="comment">// 顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="comment">// 底层</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> <span class="comment">// 顶层</span></span><br></pre></td></tr></table></figure>

<p>auto会忽略顶层const(如果需要则必须声明)，保留底层const：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> b = &amp;i;</span><br><span class="line">*b = <span class="number">2</span>; <span class="comment">// 不能更改，因为对常量(const)取地址为底层const: const int* </span></span><br></pre></td></tr></table></figure>

<p>区分什么是拷贝，什么是声明，带有类型的是声明，不带的是拷贝</p>
<p>是声明则比较是否常量指针&#x2F;引用，非常量不能指向&#x2F;绑定常量对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能用字面值初始化一个非常量引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp; a = <span class="number">42</span>; <span class="comment">// 引用需要绑定一个对象：一块具有类型的内存</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp; 取地址作用于左值，返回的指针是右值</span><br><span class="line">* 解引用 [] 下标 求值结果都为左值</span><br></pre></td></tr></table></figure>

<p>调用一个返回引用的函数得到左值，其他返回类型得到右值</p>
<p>允许将指向非常量类型的指针（引用）转换成相应的常量类型的指针（引用）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* j = &amp;i;</span><br></pre></td></tr></table></figure>

<p>相反的转换并不存在，因为它试图删除底层const</p>
<p>非常量不能指向&#x2F;绑定常量对象；可以使用非常量来初始化一个底层const对象，反之不行；</p>
<p>一个普通的引用必须用同类型的对象初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span>*)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span>&amp;)</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> i </span>= <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ci = i;</span><br><span class="line"><span class="built_in">reset</span>(&amp;ci) <span class="comment">// Error int* _ = &amp;ci is wrong</span></span><br><span class="line"><span class="built_in">reset</span>(ci) <span class="comment">// Error int&amp; _ = ci is wrong </span></span><br><span class="line"><span class="built_in">reset</span>(<span class="number">42</span>) <span class="comment">// Error 不能把普通引用绑定于字面值</span></span><br></pre></td></tr></table></figure>

<p>当初始化变量 以及 以值传递的方式传递或返回一个对象时，会发生拷贝</p>
<p>构造函数不能声明为const</p>
<p>友元允许其他类或函数访问它的非公有成员</p>
<p>this是一个常量指针，不允许改变其保存的地址（顶层const）</p>
<p>拷贝构造函数的参数必须是引用，否则需要拷贝实参，为了拷贝实参又需要调用拷贝构造，陷入循环</p>
<p>重载运算符本质上是函数，也有其返回类型与参数列表。如果一个运算符是成员函数，其左侧运算对象就绑定到隐式的this参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Fool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) <span class="comment">// 拷贝赋值运算符接受一个与其所在类相同类型的参数:</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要析构函数的类也需要拷贝与赋值操作</p>
<p>需要拷贝操作的类也需要赋值操作，反之亦然</p>
<p>右值引用：只能被绑定到一个将要被销毁的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; r1 = i; <span class="comment">// Error: 不能将一个右值引用绑定到一个左值上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r2 = i * <span class="number">42</span>; <span class="comment">// Right.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="type">int</span>&amp;&amp; r3 = std::<span class="built_in">move</span>(r1) <span class="comment">// Right.调用move就意味着承诺，除了将其赋值或销毁外不将它用于额外用途</span></span><br></pre></td></tr></table></figure>

<p>子类不能访问父类的private，但能通过父类的protected、private方法间接访问父类的private</p>
<p>子类通过public继承不会改变父类的数据属性；protected继承private是private，其余都是protected；private继承全是private</p>
<p>父类的原属性并没改变，降级的是子类在父类的个别成员属性</p>
<h2 id="2023"><a href="#2023" class="headerlink" title="2023"></a>2023</h2><h4 id="1-Cpp-1"><a href="#1-Cpp-1" class="headerlink" title="1.Cpp"></a>1.Cpp</h4><p>std::move &amp;&amp; std::forward：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384316039">https://zhuanlan.zhihu.com/p/384316039</a></p>
<p>具名的右值引用是一个左值</p>
<p>std::forward ，可以保持原始参数的类型，将实参从右值引用的左值，变成了本身就是右值引用</p>
<p>decltype：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7151.html">http://c.biancheng.net/view/7151.html</a></p>
<p>restrict: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/349726808">https://zhuanlan.zhihu.com/p/349726808</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Cpp/" rel="tag"># Cpp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/05/HPC/" rel="prev" title="HPC">
      <i class="fa fa-chevron-left"></i> HPC
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/05/Misc/" rel="next" title="Misc">
      Misc <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#2022"><span class="nav-number">1.</span> <span class="nav-text">2022</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Cpp"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.Cpp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Cherno"><span class="nav-number">1.0.2.</span> <span class="nav-text">2.Cherno</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-C-Primer"><span class="nav-number">1.0.3.</span> <span class="nav-text">3.C++ Primer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2023"><span class="nav-number">2.</span> <span class="nav-text">2023</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Cpp-1"><span class="nav-number">2.0.1.</span> <span class="nav-text">1.Cpp</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
